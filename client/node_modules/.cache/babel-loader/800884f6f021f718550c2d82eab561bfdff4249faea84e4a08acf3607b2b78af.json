{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Alex\\\\Desktop\\\\Licenta\\\\Proiect\\\\Placeholder\\\\client\\\\src\\\\components\\\\PortfolioDashboard.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState, useCallback, useMemo } from \"react\";\nimport Chart from \"chart.js/auto\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MonteCarloChart = () => {\n  _s();\n  const chartContainerRef = useRef(null);\n  const chartInstanceRef = useRef(null);\n  const assetsReturn = useMemo(() => [0.1, 0.15, 0.2], []);\n  const assetsVol = useMemo(() => [0.1, 0.2, 0.25], []);\n  const assetsCorrelationMatrix = useMemo(() => [[1.0, 0.3, 0.2], [0.3, 1.0, 0.5], [0.2, 0.5, 1.0]], []);\n  const [monteCarloPortfolios, setMonteCarloPortfolios] = useState([]);\n  const [efficientFrontierData, setEfficientFrontierData] = useState([]);\n  const [riskFreeRate, setRiskFreeRate] = useState(null);\n  useEffect(() => {\n    const cachedRate = sessionStorage.getItem(\"riskFreeRate\");\n    if (cachedRate) {\n      setRiskFreeRate(parseFloat(cachedRate));\n      console.log(\"cache\");\n    } else {\n      async function fetchRiskFreeRate() {\n        const apiKey = \"M4H1P0NX0B015FR8\";\n        const url = `https://www.alphavantage.co/query?function=TREASURY_YIELD&interval=monthly&maturity=3month&apikey=${apiKey}`;\n        try {\n          const response = await fetch(url);\n          const data = await response.json();\n          if (data[\"data\"] && data[\"data\"].length > 0) {\n            const latestRate = parseFloat(data[\"data\"].slice(-1)[0][\"value\"]);\n            sessionStorage.setItem(\"riskFreeRate\", latestRate);\n            setRiskFreeRate(latestRate);\n            console.log(\"not cache\");\n          } else {\n            console.error(\"Unexpected API response format:\", data);\n          }\n        } catch (error) {\n          console.error(\"Error fetching risk-free rate:\", error);\n        }\n      }\n      fetchRiskFreeRate();\n    }\n  }, []);\n  const calculatePortfolioMetrics = useCallback(weights => {\n    const portfolioReturn = weights.reduce((acc, weight, index) => acc + weight * assetsReturn[index], 0);\n    let portfolioVolatility = 0;\n    for (let i = 0; i < weights.length; i++) {\n      for (let j = 0; j < weights.length; j++) {\n        portfolioVolatility += weights[i] * weights[j] * assetsVol[i] * assetsVol[j] * assetsCorrelationMatrix[i][j];\n      }\n    }\n    const portfolioVolatilitySqrt = Math.sqrt(portfolioVolatility);\n    const sharpeRatio = (portfolioReturn - riskFreeRate) / portfolioVolatilitySqrt;\n    return {\n      return: portfolioReturn,\n      volatility: portfolioVolatilitySqrt,\n      sharpeRatio\n    };\n  }, [assetsReturn, assetsVol, assetsCorrelationMatrix, riskFreeRate]); // Assuming these are state variables\n\n  const generateRandomPortfolios = useCallback(() => {\n    const numPortfolios = 100;\n    return Array.from({\n      length: numPortfolios\n    }, () => {\n      const weights = Array.from({\n        length: assetsReturn.length\n      }, () => Math.random());\n      const totalWeight = weights.reduce((acc, curr) => acc + curr, 0);\n      const normalizedWeights = weights.map(weight => weight / totalWeight);\n      return calculatePortfolioMetrics(normalizedWeights);\n    });\n  }, [assetsReturn, calculatePortfolioMetrics]);\n  const optimizePortfolio = useCallback((initialWeights, targetReturn) => {\n    const tolerance = 0.0001;\n    let currentWeights = initialWeights.slice();\n    let learningRate = 0.01;\n    let iteration = 0;\n    const maxIterations = 10000;\n    const calculateReturn = weights => {\n      return weights.reduce((acc, weight, index) => acc + weight * assetsReturn[index], 0);\n    };\n    const calculateVariance = weights => {\n      let variance = 0;\n      for (let i = 0; i < weights.length; i++) {\n        for (let j = 0; j < weights.length; j++) {\n          variance += weights[i] * weights[j] * assetsVol[i] * assetsVol[j] * assetsCorrelationMatrix[i][j];\n        }\n      }\n      return variance;\n    };\n    const objectiveFunction = weights => {\n      const portReturn = calculateReturn(weights);\n      const portVariance = calculateVariance(weights);\n      const penalty = 100 * (portReturn - targetReturn) ** 2;\n      return portVariance + penalty;\n    };\n    const calculateGradient = weights => {\n      return weights.map((_, index) => {\n        const weightPlus = [...weights];\n        weightPlus[index] += 0.0001;\n        return (objectiveFunction(weightPlus) - objectiveFunction(weights)) / 0.0001;\n      });\n    };\n    const updateWeights = (weights, gradients) => {\n      const newWeights = weights.map((weight, index) => weight - learningRate * gradients[index]);\n      const totalWeight = newWeights.reduce((a, b) => a + b, 0);\n      return newWeights.map(weight => weight / totalWeight);\n    };\n    while (iteration < maxIterations) {\n      const gradients = calculateGradient(currentWeights);\n      currentWeights = updateWeights(currentWeights, gradients);\n      const change = currentWeights.reduce((acc, weight, i) => acc + Math.abs(weight - initialWeights[i]), 0);\n      if (change < tolerance) {\n        break;\n      }\n      iteration++;\n    }\n    return currentWeights;\n  }, [assetsReturn, assetsVol, assetsCorrelationMatrix]);\n  const findEfficientFrontier = useCallback(() => {\n    const targetReturns = Array.from({\n      length: 50\n    }, (_, i) => 0.05 + i * 0.005);\n    return targetReturns.map(targetReturn => {\n      const initialWeights = Array.from({\n        length: assetsReturn.length\n      }, () => 1 / assetsReturn.length);\n      const optimizedWeights = optimizePortfolio(initialWeights, targetReturn);\n      return calculatePortfolioMetrics(optimizedWeights);\n    });\n  }, [assetsReturn, optimizePortfolio, calculatePortfolioMetrics]);\n  useEffect(() => {\n    if (riskFreeRate !== null) {\n      setMonteCarloPortfolios(generateRandomPortfolios());\n      setEfficientFrontierData(findEfficientFrontier());\n    }\n  }, [riskFreeRate, generateRandomPortfolios, findEfficientFrontier]);\n  const calculateBestOutcome = useCallback(percentile => {\n    const sortedReturns = monteCarloPortfolios.map(p => p.return).sort((a, b) => a - b);\n    const index = Math.ceil(percentile * sortedReturns.length) - 1;\n    return sortedReturns[index];\n  }, [monteCarloPortfolios]);\n  useEffect(() => {\n    const formattedEfficientFrontierData = efficientFrontierData.map(portfolio => ({\n      x: portfolio.volatility,\n      y: portfolio.return\n    }));\n    const ctx = chartContainerRef.current.getContext(\"2d\");\n    if (chartInstanceRef.current) {\n      chartInstanceRef.current.destroy();\n    }\n    chartInstanceRef.current = new Chart(ctx, {\n      type: \"scatter\",\n      data: {\n        datasets: [{\n          label: \"Efficient Frontier\",\n          data: formattedEfficientFrontierData,\n          backgroundColor: \"transparent\",\n          borderColor: \"red\",\n          borderWidth: 2,\n          pointRadius: 0,\n          showLine: true,\n          fill: false\n        }, {\n          label: \"Random Portfolios\",\n          data: monteCarloPortfolios.map(portfolio => ({\n            x: portfolio.volatility,\n            y: portfolio.return\n          })),\n          backgroundColor: \"rgba(128, 128, 128, 0.5)\",\n          pointRadius: 5\n        }]\n      },\n      options: {\n        onClick: (event, elements) => {\n          if (elements.length > 0) {\n            const clickedIndex = elements[0].index;\n            const clickedPortfolio = monteCarloPortfolios[clickedIndex];\n            console.log(`Expected Return: ${clickedPortfolio.return.toFixed(2)}%`);\n            console.log(`Risk (CVaR 1%): ${clickedPortfolio.volatility.toFixed(2)}%`);\n            const bestOutcomeReturn = calculateBestOutcome(0.99);\n            console.log(`Best outcome (CVaR 99%): ${(bestOutcomeReturn * 100).toFixed(2)}%`);\n            const clickedWeights = optimizePortfolio(Array.from({\n              length: assetsReturn.length\n            }, () => 1 / assetsReturn.length), clickedPortfolio.return).map(weight => (weight * 100).toFixed(2));\n            console.log(`Portfolio components: Asset 1 ${clickedWeights[0]}%, Asset 2 ${clickedWeights[1]}%, Asset 3 ${clickedWeights[2]}%`);\n          }\n        },\n        scales: {\n          x: {\n            title: {\n              display: true,\n              text: \"Volatility (Standard Deviation)\"\n            },\n            beginAtZero: true\n          },\n          y: {\n            title: {\n              display: true,\n              text: \"Expected Return\"\n            },\n            beginAtZero: true\n          }\n        }\n      }\n    });\n    return () => {\n      if (chartInstanceRef.current) {\n        chartInstanceRef.current.destroy();\n      }\n    };\n  }, [monteCarloPortfolios, efficientFrontierData, optimizePortfolio, assetsReturn.length, calculateBestOutcome]);\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: chartContainerRef,\n    width: \"400\",\n    height: \"400\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 310,\n    columnNumber: 10\n  }, this);\n};\n_s(MonteCarloChart, \"G2R+aEHYlAU1Uac29XRCjH1BYPw=\");\n_c = MonteCarloChart;\nexport default MonteCarloChart;\nvar _c;\n$RefreshReg$(_c, \"MonteCarloChart\");","map":{"version":3,"names":["React","useEffect","useRef","useState","useCallback","useMemo","Chart","jsxDEV","_jsxDEV","MonteCarloChart","_s","chartContainerRef","chartInstanceRef","assetsReturn","assetsVol","assetsCorrelationMatrix","monteCarloPortfolios","setMonteCarloPortfolios","efficientFrontierData","setEfficientFrontierData","riskFreeRate","setRiskFreeRate","cachedRate","sessionStorage","getItem","parseFloat","console","log","fetchRiskFreeRate","apiKey","url","response","fetch","data","json","length","latestRate","slice","setItem","error","calculatePortfolioMetrics","weights","portfolioReturn","reduce","acc","weight","index","portfolioVolatility","i","j","portfolioVolatilitySqrt","Math","sqrt","sharpeRatio","return","volatility","generateRandomPortfolios","numPortfolios","Array","from","random","totalWeight","curr","normalizedWeights","map","optimizePortfolio","initialWeights","targetReturn","tolerance","currentWeights","learningRate","iteration","maxIterations","calculateReturn","calculateVariance","variance","objectiveFunction","portReturn","portVariance","penalty","calculateGradient","_","weightPlus","updateWeights","gradients","newWeights","a","b","change","abs","findEfficientFrontier","targetReturns","optimizedWeights","calculateBestOutcome","percentile","sortedReturns","p","sort","ceil","formattedEfficientFrontierData","portfolio","x","y","ctx","current","getContext","destroy","type","datasets","label","backgroundColor","borderColor","borderWidth","pointRadius","showLine","fill","options","onClick","event","elements","clickedIndex","clickedPortfolio","toFixed","bestOutcomeReturn","clickedWeights","scales","title","display","text","beginAtZero","ref","width","height","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Alex/Desktop/Licenta/Proiect/Placeholder/client/src/components/PortfolioDashboard.js"],"sourcesContent":["import React, {\r\n  useEffect,\r\n  useRef,\r\n  useState,\r\n  useCallback,\r\n  useMemo,\r\n} from \"react\";\r\nimport Chart from \"chart.js/auto\";\r\n\r\nconst MonteCarloChart = () => {\r\n  const chartContainerRef = useRef(null);\r\n  const chartInstanceRef = useRef(null);\r\n\r\n  const assetsReturn = useMemo(() => [0.1, 0.15, 0.2], []);\r\n  const assetsVol = useMemo(() => [0.1, 0.2, 0.25], []);\r\n  const assetsCorrelationMatrix = useMemo(\r\n    () => [\r\n      [1.0, 0.3, 0.2],\r\n      [0.3, 1.0, 0.5],\r\n      [0.2, 0.5, 1.0],\r\n    ],\r\n    []\r\n  );\r\n\r\n  const [monteCarloPortfolios, setMonteCarloPortfolios] = useState([]);\r\n  const [efficientFrontierData, setEfficientFrontierData] = useState([]);\r\n  const [riskFreeRate, setRiskFreeRate] = useState(null);\r\n\r\n  useEffect(() => {\r\n    const cachedRate = sessionStorage.getItem(\"riskFreeRate\");\r\n    if (cachedRate) {\r\n      setRiskFreeRate(parseFloat(cachedRate));\r\n      console.log(\"cache\");\r\n    } else {\r\n      async function fetchRiskFreeRate() {\r\n        const apiKey = \"M4H1P0NX0B015FR8\";\r\n        const url = `https://www.alphavantage.co/query?function=TREASURY_YIELD&interval=monthly&maturity=3month&apikey=${apiKey}`;\r\n        try {\r\n          const response = await fetch(url);\r\n          const data = await response.json();\r\n          if (data[\"data\"] && data[\"data\"].length > 0) {\r\n            const latestRate = parseFloat(data[\"data\"].slice(-1)[0][\"value\"]);\r\n            sessionStorage.setItem(\"riskFreeRate\", latestRate);\r\n            setRiskFreeRate(latestRate);\r\n            console.log(\"not cache\");\r\n          } else {\r\n            console.error(\"Unexpected API response format:\", data);\r\n          }\r\n        } catch (error) {\r\n          console.error(\"Error fetching risk-free rate:\", error);\r\n        }\r\n      }\r\n      fetchRiskFreeRate();\r\n    }\r\n  }, []);\r\n\r\n  const calculatePortfolioMetrics = useCallback(\r\n    (weights) => {\r\n      const portfolioReturn = weights.reduce(\r\n        (acc, weight, index) => acc + weight * assetsReturn[index],\r\n        0\r\n      );\r\n      let portfolioVolatility = 0;\r\n      for (let i = 0; i < weights.length; i++) {\r\n        for (let j = 0; j < weights.length; j++) {\r\n          portfolioVolatility +=\r\n            weights[i] *\r\n            weights[j] *\r\n            assetsVol[i] *\r\n            assetsVol[j] *\r\n            assetsCorrelationMatrix[i][j];\r\n        }\r\n      }\r\n      const portfolioVolatilitySqrt = Math.sqrt(portfolioVolatility);\r\n      const sharpeRatio =\r\n        (portfolioReturn - riskFreeRate) / portfolioVolatilitySqrt;\r\n\r\n      return {\r\n        return: portfolioReturn,\r\n        volatility: portfolioVolatilitySqrt,\r\n        sharpeRatio,\r\n      };\r\n    },\r\n    [assetsReturn, assetsVol, assetsCorrelationMatrix, riskFreeRate]\r\n  ); // Assuming these are state variables\r\n\r\n  const generateRandomPortfolios = useCallback(() => {\r\n    const numPortfolios = 100;\r\n    return Array.from({ length: numPortfolios }, () => {\r\n      const weights = Array.from({ length: assetsReturn.length }, () =>\r\n        Math.random()\r\n      );\r\n      const totalWeight = weights.reduce((acc, curr) => acc + curr, 0);\r\n      const normalizedWeights = weights.map((weight) => weight / totalWeight);\r\n      return calculatePortfolioMetrics(normalizedWeights);\r\n    });\r\n  }, [assetsReturn, calculatePortfolioMetrics]);\r\n\r\n  const optimizePortfolio = useCallback(\r\n    (initialWeights, targetReturn) => {\r\n      const tolerance = 0.0001;\r\n      let currentWeights = initialWeights.slice();\r\n      let learningRate = 0.01;\r\n      let iteration = 0;\r\n      const maxIterations = 10000;\r\n\r\n      const calculateReturn = (weights) => {\r\n        return weights.reduce(\r\n          (acc, weight, index) => acc + weight * assetsReturn[index],\r\n          0\r\n        );\r\n      };\r\n\r\n      const calculateVariance = (weights) => {\r\n        let variance = 0;\r\n        for (let i = 0; i < weights.length; i++) {\r\n          for (let j = 0; j < weights.length; j++) {\r\n            variance +=\r\n              weights[i] *\r\n              weights[j] *\r\n              assetsVol[i] *\r\n              assetsVol[j] *\r\n              assetsCorrelationMatrix[i][j];\r\n          }\r\n        }\r\n        return variance;\r\n      };\r\n\r\n      const objectiveFunction = (weights) => {\r\n        const portReturn = calculateReturn(weights);\r\n        const portVariance = calculateVariance(weights);\r\n        const penalty = 100 * (portReturn - targetReturn) ** 2;\r\n        return portVariance + penalty;\r\n      };\r\n\r\n      const calculateGradient = (weights) => {\r\n        return weights.map((_, index) => {\r\n          const weightPlus = [...weights];\r\n          weightPlus[index] += 0.0001;\r\n          return (\r\n            (objectiveFunction(weightPlus) - objectiveFunction(weights)) /\r\n            0.0001\r\n          );\r\n        });\r\n      };\r\n\r\n      const updateWeights = (weights, gradients) => {\r\n        const newWeights = weights.map(\r\n          (weight, index) => weight - learningRate * gradients[index]\r\n        );\r\n        const totalWeight = newWeights.reduce((a, b) => a + b, 0);\r\n        return newWeights.map((weight) => weight / totalWeight);\r\n      };\r\n\r\n      while (iteration < maxIterations) {\r\n        const gradients = calculateGradient(currentWeights);\r\n\r\n        currentWeights = updateWeights(currentWeights, gradients);\r\n\r\n        const change = currentWeights.reduce(\r\n          (acc, weight, i) => acc + Math.abs(weight - initialWeights[i]),\r\n          0\r\n        );\r\n        if (change < tolerance) {\r\n          break;\r\n        }\r\n\r\n        iteration++;\r\n      }\r\n\r\n      return currentWeights;\r\n    },\r\n    [assetsReturn, assetsVol, assetsCorrelationMatrix]\r\n  );\r\n\r\n  const findEfficientFrontier = useCallback(() => {\r\n    const targetReturns = Array.from(\r\n      { length: 50 },\r\n      (_, i) => 0.05 + i * 0.005\r\n    );\r\n    return targetReturns.map((targetReturn) => {\r\n      const initialWeights = Array.from(\r\n        { length: assetsReturn.length },\r\n        () => 1 / assetsReturn.length\r\n      );\r\n      const optimizedWeights = optimizePortfolio(initialWeights, targetReturn);\r\n      return calculatePortfolioMetrics(optimizedWeights);\r\n    });\r\n  }, [assetsReturn, optimizePortfolio, calculatePortfolioMetrics]);\r\n\r\n  useEffect(() => {\r\n    if (riskFreeRate !== null) {\r\n      setMonteCarloPortfolios(generateRandomPortfolios());\r\n      setEfficientFrontierData(findEfficientFrontier());\r\n    }\r\n  }, [riskFreeRate, generateRandomPortfolios, findEfficientFrontier]);\r\n\r\n  const calculateBestOutcome = useCallback(\r\n    (percentile) => {\r\n      const sortedReturns = monteCarloPortfolios\r\n        .map((p) => p.return)\r\n        .sort((a, b) => a - b);\r\n      const index = Math.ceil(percentile * sortedReturns.length) - 1;\r\n      return sortedReturns[index];\r\n    },\r\n    [monteCarloPortfolios]\r\n  );\r\n\r\n  useEffect(() => {\r\n    const formattedEfficientFrontierData = efficientFrontierData.map(\r\n      (portfolio) => ({\r\n        x: portfolio.volatility,\r\n        y: portfolio.return,\r\n      })\r\n    );\r\n\r\n    const ctx = chartContainerRef.current.getContext(\"2d\");\r\n    if (chartInstanceRef.current) {\r\n      chartInstanceRef.current.destroy();\r\n    }\r\n    chartInstanceRef.current = new Chart(ctx, {\r\n      type: \"scatter\",\r\n      data: {\r\n        datasets: [\r\n          {\r\n            label: \"Efficient Frontier\",\r\n            data: formattedEfficientFrontierData,\r\n            backgroundColor: \"transparent\",\r\n            borderColor: \"red\",\r\n            borderWidth: 2,\r\n            pointRadius: 0,\r\n            showLine: true,\r\n            fill: false,\r\n          },\r\n          {\r\n            label: \"Random Portfolios\",\r\n            data: monteCarloPortfolios.map((portfolio) => ({\r\n              x: portfolio.volatility,\r\n              y: portfolio.return,\r\n            })),\r\n            backgroundColor: \"rgba(128, 128, 128, 0.5)\",\r\n            pointRadius: 5,\r\n          },\r\n        ],\r\n      },\r\n      options: {\r\n        onClick: (event, elements) => {\r\n          if (elements.length > 0) {\r\n            const clickedIndex = elements[0].index;\r\n            const clickedPortfolio = monteCarloPortfolios[clickedIndex];\r\n            console.log(\r\n              `Expected Return: ${clickedPortfolio.return.toFixed(2)}%`\r\n            );\r\n            console.log(\r\n              `Risk (CVaR 1%): ${clickedPortfolio.volatility.toFixed(2)}%`\r\n            );\r\n\r\n            const bestOutcomeReturn = calculateBestOutcome(0.99);\r\n            console.log(\r\n              `Best outcome (CVaR 99%): ${(bestOutcomeReturn * 100).toFixed(\r\n                2\r\n              )}%`\r\n            );\r\n\r\n            const clickedWeights = optimizePortfolio(\r\n              Array.from(\r\n                { length: assetsReturn.length },\r\n                () => 1 / assetsReturn.length\r\n              ),\r\n              clickedPortfolio.return\r\n            ).map((weight) => (weight * 100).toFixed(2));\r\n\r\n            console.log(\r\n              `Portfolio components: Asset 1 ${clickedWeights[0]}%, Asset 2 ${clickedWeights[1]}%, Asset 3 ${clickedWeights[2]}%`\r\n            );\r\n          }\r\n        },\r\n        scales: {\r\n          x: {\r\n            title: {\r\n              display: true,\r\n              text: \"Volatility (Standard Deviation)\",\r\n            },\r\n            beginAtZero: true,\r\n          },\r\n          y: {\r\n            title: {\r\n              display: true,\r\n              text: \"Expected Return\",\r\n            },\r\n            beginAtZero: true,\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    return () => {\r\n      if (chartInstanceRef.current) {\r\n        chartInstanceRef.current.destroy();\r\n      }\r\n    };\r\n  }, [\r\n    monteCarloPortfolios,\r\n    efficientFrontierData,\r\n    optimizePortfolio,\r\n    assetsReturn.length,\r\n    calculateBestOutcome,\r\n  ]);\r\n\r\n  return <canvas ref={chartContainerRef} width=\"400\" height=\"400\"></canvas>;\r\n};\r\n\r\nexport default MonteCarloChart;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}